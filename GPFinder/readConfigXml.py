from xml.dom import minidom
import xml.parsers.expat as expat
import sys


class configuration(dict):

    def __init__(self):
        
        # Function Description:
        #     Read in the GP3Config.xml, which is generated by an online form
        # Function Input:
        #     A user-defined online form setting
        # Function Output:
        #     None
        

        #base cases, opening and parsing config file xml
        try:
            file = open("GP3Config.xml", "rb")
            configDom = minidom.parse(file)
        except IOError:
            print("ioError: GP3Config.xml not found")
        #ExpatError generated when parsing XML fails
        except expat.ExpatError:
            print("GP3Config.xml not in XML format:")
            for entry in sys.exc_info():
                print(entry)

        #
        #get all entries, test for content
        #
        try:
            #glycanchemN = configDom.getElementsByTagName('glycanchem')[0]
            decoyN = configDom.getElementsByTagName('decoy')[0]
        except IndexError:
            print("missing required configuration fields: check tags 'glycanchem', 'glycanstatus', or 'decoy'")
            for entry in sys.exc_info():
                print(entry)
                
        try:
            massSpecN = configDom.getElementsByTagName('massspec')[0]
            toleranceN = massSpecN.getElementsByTagName('toleranceAbsolutePPM')[0]
        except IndexError:
            print("missing 1 or more required configuration fields: 'massspec tag' or child tag")
            for entry in sys.exc_info():
                print(entry)
                
        try:        
            filesN = configDom.getElementsByTagName('files')[0]
            proteinFileN = filesN.getElementsByTagName('proteinfile')[0]
            aaMassFileN = filesN.getElementsByTagName('aamassfile')[0]
            saccharideFileN = filesN.getElementsByTagName('saccharidefile')[0]
            glycanLibraryFileN = filesN.getElementsByTagName('glycanlibraryfile')[0]
        except IndexError:
            print("missing 1 or more required configuration fields: 'files' tag or child tag")
            for entry in sys.exc_info():
                print(entry)

        try:
            allowedFormats = ["cef", "mgf", "mzdata"]
            msFileNode = filesN.getElementsByTagName("massspecfile")[0]
            msFormat = msFileNode.getAttribute("format").strip().lower()
            if msFormat not in allowedFormats:
                raise Exception("Need to use allowed format: try cef, mgf, or mzdata")
            msFileName = msFileNode.getAttribute("filename").strip()
            if msFileName == "":
                raise Exception("Need to have a cef file when cef is selected.")
            
        except IndexError:
            print("missing 1 or more required configuration fields on cef or/and mgf.")
            for entry in sys.exc_info():
                print(entry)
            
        try:        
            proteinN = configDom.getElementsByTagName("protein")[0]
            sequenceN = proteinN.getElementsByTagName("sequence")[0]
            digestionN = proteinN.getElementsByTagName("digestion")[0]
            modifiedresidueN = proteinN.getElementsByTagName("modifiedresidue")[0]
            phosphorylationNodes = modifiedresidueN.getElementsByTagName("phosphorylation")
            carbamidomethylationNodes = modifiedresidueN.getElementsByTagName("carbamidomethylation")
            deamidationNodes = modifiedresidueN.getElementsByTagName("deamidation")
            oxidationNodes = modifiedresidueN.getElementsByTagName("oxidation")
        except IndexError:
            print("missing 1 or more required configuration fields: 'protein' tag or child tag")
            for entry in sys.exc_info():
                print(entry)

        try:
            fragmentIonChargeNode = configDom.getElementsByTagName("fragmentioncharge")[0]
            maxPossibleFragmentIonCharge = float(fragmentIonChargeNode.getAttribute("maxpossiblefragmentioncharge").strip())
            if int(maxPossibleFragmentIonCharge) != maxPossibleFragmentIonCharge:
                raise Exception("Error: fragment ion charges can only be integers.")
            if maxPossibleFragmentIonCharge < 0:
                raise Exception("Error: fragment ion charges can only be positive.")
            maxPossibleFragmentIonCharge = int(maxPossibleFragmentIonCharge)
            
        except IndexError:
            print("missing field 'maxpossiblefragmentioncharge'")
            for entry in sys.exc_info():
                print(entry)
                
        try:
            fragmentNoseFilterNode = configDom.getElementsByTagName("fragmentnoisefilter")[0]
            applyFragmentNoiseFilter = bool(fragmentNoseFilterNode.getAttribute("value").strip())
            if applyFragmentNoiseFilter == True:
                noiseCutoffThreshold = float(fragmentNoseFilterNode.getAttribute("noisecutoffthreshold").strip())
                if noiseCutoffThreshold <= 0:
                    raise Exception("Noise Cutoff Threshold needs to be positive.")
        except IndexError:
            print("at least one of 'value' and 'noisecutoffthreshold' needs to be defined")
            for entry in sys.exc_info():
                print(entry)
                
        try:
            diagnosticFragmentNode = configDom.getElementsByTagName("diagnosticfragmentfilter")[0]
            applyDiagnosticFragment = bool(diagnosticFragmentNode.getAttribute("value").strip())
            if applyDiagnosticFragment == True:
                diagnosticFragmentCutoff = float(diagnosticFragmentNode.getAttribute("fractionofmax").strip())
                diagnosticNumberRequired = float(diagnosticFragmentNode.getAttribute("numberrequired").strip())
                if diagnosticFragmentCutoff <= 0:
                    raise Exception("Diagnostic Fragment Cutoff (fractionofmax) needs to be positive.")
                if diagnosticNumberRequired < 0:
                    raise Exception("Number of Diagnostic Fragments that are required to be spun on (numberrequired) needs to be a non-negative integer.")
                if diagnosticNumberRequired != int(diagnosticNumberRequired):
                    raise Exception("Number of Diagnostic Fragments that are required to be spun on (numberrequired) needs to be a non-negative integer.")
                diagnosticNumberRequired = int(diagnosticNumberRequired)
        except IndexError:
            print("at least one 'value' and 'fractionofmax' needs to be defined within a 'diagnosticfragmentfilter' tag")
            for entry in sys.exc_info():
                print(entry)
 
        # determine whether N-linked glycosylation is searched,
        # and whether O-linked glycosylation is searched.

        try:
            glycosylationTypeNode = configDom.getElementsByTagName("glycosylationtype")[0]
            searchForNLinked = bool(glycosylationTypeNode.getAttribute("searchfornlinked"))
            searchForOLinked = bool(glycosylationTypeNode.getAttribute("searchforolinked"))
            if searchForNLinked == False and searchForOLinked == False:
                raise Exception("searchForNLinked and searchForOLinked cannot be False simultaneously.")
        except IndexError:
            print("missing 1 or more requirec configuration fields: 'glycosylationType' tag or child tag")
            for entry in sys.exc_info():
                print(entry)
                
        try:        
            glycanN = configDom.getElementsByTagName('glycan')[0]
            methodN = glycanN.getElementsByTagName('method')[0]
            combinatorialN = glycanN.getElementsByTagName('combinatorial')[0]
        except IndexError:
            print("missing 1 or more required configuration fields: 'glycan' tag or child tag")
            for entry in sys.exc_info():
                print(entry)

        combinatorialDictKeys = ['Hex', 'HexNAc', 'DeoxyHex', 'Neu5Ac',
                                 'Neu5Gc', 'Pentose', 'KDN', 'HexA']
        
        try:
            combinatorialNodeDict = {}
            for key in combinatorialDictKeys:
                combinatorialNodeDict[key] =  combinatorialN.getElementsByTagName(key)[0]
        except IndexError:
            print("missing 1 or more required configuration fields: 'combinatorial' tag or child tag")
            for entry in sys.exc_info():
                print(entry)

        try:
            scoringParametersNode = configDom.getElementsByTagName('scoringparameters')[0]
            msNode = scoringParametersNode.getElementsByTagName("ms")[0]
            scoringToleranceNode = msNode.getElementsByTagName('toleranceAbsolutePPM')[0]
            scoringTolerancePPM = float(scoringToleranceNode.getAttribute("value").strip())
            scoringToleranceMassNode = msNode.getElementsByTagName("toleranceAbsoluteMass")[0]
            scoringToleranceMass = float(scoringToleranceMassNode.getAttribute("value").strip())
            
        except IndexError:
            print("missing 1 or more required configuration fields: 'scoringparameters tag' or child tag")
            for entry in sys.exc_info():
                print(entry)

        try:
            printingOptionsN = configDom.getElementsByTagName("printingoptions")[0]
            printMatchDetails = bool(printingOptionsN.getAttribute("printmatchdetails").strip())
        except IndexError:
            print("missing field 'printmatchdetails'")
            for entry in sys.exc_info():
                print(entry)

        try:
            testOptionsNode = configDom.getElementsByTagName("testoptions")[0]
            testEnabled = bool(testOptionsNode.getAttribute("test").strip())
        except IndexError:
            print("missing field 'testEnabled'")
            for entry in sys.exc_info():
                print(entry)
        #       
        # buildDictionary
        #
        
        # find tolerance PPM value and compute 1-shoulder tolerance
        tolerance =  float(toleranceN.getAttribute('value').strip())
        self["tolerancePPM"] = tolerance
        self["tolerance"] = tolerance / 1000000.0
        
        # Feature no longer supported
        # find glycan chemistry status bool(free), chemistry:(released, reduced)
        self["free"] = False #bool(glycanStatusN.getAttribute('free').strip())
        #self["glycanChemistry"] = str(glycanStatusN.getAttribute('chemistry'))
        
        # this is kept for compatibility <---------delete soon
        self["reduced"] = False # bool(glycanchemN.getAttribute('reduced').strip())
        self["deuterated"] = False # bool(glycanchemN.getAttribute('deuterated').strip())
        
        
        # get decoy analysis options
        self["decoyAnalysis"] = bool(decoyN.getAttribute('checkbox').strip())
        self["decoyMass"] = float(decoyN.getAttribute('value').strip())
        
        #protein digest type, missed cleavages, give error if out of bound
        digestionN = proteinN.getElementsByTagName("digestion")[0]
        digestionTypeN = digestionN.getElementsByTagName("type")[0]
        
        applyNonspecific = bool(digestionTypeN.getAttribute("nonspecific").strip())
        applyTrypsin = bool(digestionTypeN.getAttribute("trypsin").strip())
        applyLysc = bool(digestionTypeN.getAttribute("lysc").strip())
        applyGluc = bool(digestionTypeN.getAttribute("gluc").strip())
        #argc="" pepsin="" elastase="" chymotrypsin="" applyArgc applyPepsin applyElastase applyChymotrypsin
        applyArgc = bool(digestionTypeN.getAttribute("argc").strip())
        applyPepsin = bool(digestionTypeN.getAttribute("pepsin").strip())
        applyElastase = bool(digestionTypeN.getAttribute("elastase").strip())
        applyChymotrypsin = bool(digestionTypeN.getAttribute("chymotrypsin").strip())
        
        missedCleavagesN = digestionN.getElementsByTagName("missedcleavages")[0]
        missedCleavages = missedCleavagesN.getAttribute("max").strip()

        if missedCleavages == "":
            missedCleavages = 0

        missedCleavages = int(missedCleavages)
        
        listOfDigestTypes = []

        if applyNonspecific == True:
            listOfDigestTypes.append("nonspecific")
            if applyTrypsin == True:
                print("Warning: trypsin used with nonspecific. Nonspecific includes trypsin so we only do nonspecific")
            if applyLysc == True:
                print("Warning: Lys-C used with nonspecific. Nonspecific overwrites Lys-C so we only do nonspecific")
            if applyGluc == True or applyArgc == True or applyPepsin == True or applyElastase == True or applyChymotrypsin == True:
                print("Warning: secondary enzyme used with nonspecific. Nonspecific overwrites Glu-C so we only do nonspecific")
        else:
            if applyTrypsin == True:
                listOfDigestTypes.append("trypsin")
            if applyArgc == True:
                listOfDigestTypes.append("argc")
            if applyPepsin == True:
                listOfDigestTypes.append("pepsin")
            if applyElastase == True:
                listOfDigestTypes.append("elastase")
            if applyChymotrypsin == True:
                listOfDigestTypes.append("chymotrypsin")
            if applyLysc == True:
                listOfDigestTypes.append("lysc")
            if applyGluc == True:
                listOfDigestTypes.append("gluc")
            if (applyNonspecific == False
                    and applyTrypsin == False
                    and applyLysc == False
                    and applyGluc == False
                    and applyPepsin == False
                    and applyArgc == False
                    and applyElastase == False
                    and applyChymotrypsin == False):
                raise Exception("No digestion method found, need to specify at least one digestion method")

        if missedCleavages < 0:
            raise Exception("Number of miss cleavages needs to positive.")
        if "nonspecific" in listOfDigestTypes or "elastase" in listOfDigestTypes:
            if missedCleavages > 18:
                raise Exception("Too many miss cleavages for nonspecific digestion")
        if "nonspecific" not in listOfDigestTypes and "elastase" not in listOfDigestTypes:
            if missedCleavages > 8:
                raise Exception("Too many miss cleavages for site-specific digestion")
            
        self["digestTypes"] = listOfDigestTypes
        self["missedCleavages"] = missedCleavages
        
        #getting sequence info; uniprot or user entered, strip formatting characters.
        self["uniprot"] = bool(sequenceN.getAttribute("uniprot").strip())
        sequence = sequenceN.getAttribute("sequence").strip()
        self["autoDetectNSites"] = bool(sequenceN.getAttribute("autodetectnsites").strip())
        if sequenceN.getAttribute("sitelist"):
            self["listOfSites"] = [int(oneSiteIndex.strip())
                                   for oneSiteIndex
                                   in sequenceN.getAttribute("sitelist").split(",")]
        else:
            self["listOfSites"] = []

        if self["free"] == False:
            if self["uniprot"] == False and sequence == "":
                raise Exception("Error: need to have a sequence for glycopeptide")
            elif self["uniprot"] == True and sequence != "":
                raise Exception("Error: cannot have two sequences for glycopeptide")
            elif self["uniprot"] == True and sequence == "":
                self["isSequenceGivenByUser"] = False
            elif self["uniprot"] == False and sequence != "":
                self["isSequenceGivenByUser"] = True
                betterSequence = ""
                for char in sequence:
                    if char.isalpha():
                        betterSequence += char
                self["sequence"] = betterSequence
                sequenceDict = {}
                for i in range(len(betterSequence)):
                    sequenceDict[i+1] = betterSequence[i]
                self["sequenceDict"] = sequenceDict
        else:
            self["isSequenceGivenByUser"] = False
            
        #get files and folders
        folder = filesN.getAttribute("folder")
        self["resourceFolder"] = folder
        fullFolder = "./" + folder + "/"

        # now we can get more than one protein xml input
        stringOfProteinFiles = proteinFileN.getAttribute("filename").strip()
        listOfProteinFiles = [fullFolder + proteinFile.strip()
                              for proteinFile in stringOfProteinFiles.split(",")]
        self["listOfProteinFiles"] = listOfProteinFiles

        self["listOfProteinNames"] = []
        
        proteinFile = fullFolder + proteinFileN.getAttribute("filename").strip()
        self["proteinFile"] = proteinFile
        aaMassFile = fullFolder + aaMassFileN.getAttribute("filename").strip()
        self["aaMassFile"] = aaMassFile
        saccharideFile = fullFolder + saccharideFileN.getAttribute("filename").strip()
        self["saccharideFile"] = saccharideFile
        glycanLibraryFile = fullFolder + glycanLibraryFileN.getAttribute("filename").strip()
        self["glycanLibraryFile"] = glycanLibraryFile
        
        """
        self["applyCef"] = applyCef
        if applyCef == True:
            cefFile = fullFolder + cefFile
            self["cefFile"] = cefFile
            
        self["applyMgf"] = applyMgf
        if applyMgf == True:
            mgfFile = fullFolder + mgfFile
            self["mgfFile"] = mgfFile
        """
        
        self["msFile"] = fullFolder + msFileName
        self["msFormat"] = msFormat
        
        # let user decide which is the max possible fragment ion charge
        # if the ion charge is NOT present in the cef
        self["maxPossibleFragmentIonCharge"] = maxPossibleFragmentIonCharge
        
        # find whether we apply kernel density estimation and if yes, what's the cutoff threshold
        self["applyFragmentNoiseFilter"] = applyFragmentNoiseFilter
        if applyFragmentNoiseFilter == True:
            self["noiseCutoffThreshold"] = noiseCutoffThreshold
        
        # find whether we apply diagnostic fragment filter and, if yes, what's the cutoff threshold
        self["applyDiagnosticIonFilter"] = applyDiagnosticFragment
        if applyDiagnosticFragment == True:
            self["diagnosticIonCutoff"] = diagnosticFragmentCutoff
            self["diagnosticNumberRequired"] = diagnosticNumberRequired
        
        # find phosphorylation sites: user configured
        listOfPhosphorylationTuples = []
        for phosphorylationNode in phosphorylationNodes:
            aminoAcid = str(phosphorylationNode.getAttribute("type").strip())
            phosphorylation = bool(phosphorylationNode.getAttribute("checkbox").strip())
            phosphorylationTuple = (aminoAcid, phosphorylation)
            listOfPhosphorylationTuples.append(phosphorylationTuple)
        self["listOfPhosphorylationTuples"] = listOfPhosphorylationTuples

        # find carbamidomethylation sites: user configured
        listOfCarbamidomethylationTuples = []
        listOfCarbamidomethylationsThatApplyToAll = []
        for carbamidomethylationNode in carbamidomethylationNodes:
            aminoAcid = str(carbamidomethylationNode.getAttribute("type").strip())
            carbamidomethylation = bool(carbamidomethylationNode.getAttribute("checkbox").strip())
            carbamidomethylationTuple = (aminoAcid, carbamidomethylation)
            listOfCarbamidomethylationTuples.append(carbamidomethylationTuple)
            if carbamidomethylation == True:
                carbamidomethylationAppliedToAll = bool(carbamidomethylationNode.getAttribute("applytoall"))
                if carbamidomethylationAppliedToAll == True:
                    listOfCarbamidomethylationsThatApplyToAll.append(aminoAcid)                                                           
        self["listOfCarbamidomethylationTuples"] = listOfCarbamidomethylationTuples
        self["listOfCarbamidomethylationsThatApplyToAll"] = listOfCarbamidomethylationsThatApplyToAll
        
        # find deamidation sites: user configured
        listOfDeamidationTuples = []
        for deamidationNode in deamidationNodes:
            aminoAcid = str(deamidationNode.getAttribute("type").strip())
            deamidation = bool(deamidationNode.getAttribute("checkbox"))
            deamidationTuple = (aminoAcid, deamidation)
            listOfDeamidationTuples.append(deamidationTuple)
        self["listOfDeamidationTuples"] = listOfDeamidationTuples

        # find oxidation sites: user configured
        listOfOxidationTuples = []
        for oxidationNode in oxidationNodes:
            aminoAcid = str(oxidationNode.getAttribute("type").strip())
            oxidation = bool(oxidationNode.getAttribute("checkbox"))
            oxidationTuple = (aminoAcid, oxidation)
            listOfOxidationTuples.append(oxidationTuple)
        self["listOfOxidationTuples"] = listOfOxidationTuples

        # get the query on whether we search for N-Linked glycosylation sites
        # and whether we search for O-Linked glycosylation sites
        self["searchForNLinked"] = searchForNLinked
        self["searchForOLinked"] = searchForOLinked
        
        # get glycan analysis method (dictionary or combinatorial)
        searchType = methodN.getAttribute("value").strip()
        if searchType == "library":
            self["glycanSearchMethod"] = "genericlibrary"
        elif searchType == "combinatorial":
            self["glycanSearchMethod"] = "combinatorial"
        else:
            print("Unsupported glycan search type, in the configuration\n" +
                  "<glyca,><method> node, the 'value', attribute must be\n" +
                  '"combinatorial" or "library"')
            raw_input()
            sys.exit()
        
        # set up min,max dictionary
        glycanComponentMinMaxDict = {}
        for glycanComponent in combinatorialDictKeys:
            glycanComponentMinMaxDict[glycanComponent] = {"min": 0, "max": 0}
            node = combinatorialNodeDict[glycanComponent]
            minimum = int(node.getAttribute("min").strip())
            glycanComponentMinMaxDict[glycanComponent]["min"] = minimum
            maximum = int(node.getAttribute("max").strip())
            glycanComponentMinMaxDict[glycanComponent]["max"] = maximum
            
        self["glycanComponentMinMaxDict"] = glycanComponentMinMaxDict

        # set up the scoring parameters
        self["scoringTolerancePPM"] = scoringTolerancePPM
        self["scoringTolerance"] = scoringTolerancePPM / 1000000.0
        self["scoringToleranceMass"] = scoringToleranceMass
    
        self["printMatchDetails"] = printMatchDetails

        self["testEnabled"] = testEnabled
        
#x = configuration()
#print(x)
